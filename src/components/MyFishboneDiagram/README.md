# 鱼骨图组件开发指南

## 目录

1. [整体介绍](#1-整体介绍)
2. [技术栈](#2-技术栈)
3. [数据结构](#3-数据结构)
4. [架构概览](#4-架构概览)
5. [布局算法详解](#5-布局算法详解)
6. [编辑交互](#6-编辑交互)
7. [画布平移与缩放](#7-画布平移与缩放)
8. [可调参数速查表](#8-可调参数速查表)
9. [关键函数索引](#9-关键函数索引)

---

## 1. 整体介绍

鱼骨图（又叫石川图、因果图）是一种用来分析问题根因的图表。整体形状像一条鱼：

```
                          ┌─ 小骨
                  ┌─ 中骨 ┤
         ┌─ 大骨 ┤        └─ 小骨
         │       └─ 中骨
鱼尾 ════╪════════════════════════ 鱼头（问题）
         │       ┌─ 中骨
         └─ 大骨 ┤
                  └─ 中骨 ── 小骨
```

- **鱼头**：右侧，写问题描述
- **主骨线**：水平中轴线
- **大骨**：从主骨线斜向上/下延伸，代表主要原因分类
- **中骨**：从大骨斜线上水平向左延伸，代表具体原因
- **小骨**：从中骨方框左侧延伸，代表更细的子原因
- **鱼尾**：左侧装饰

## 2. 技术栈

| 技术 | 作用 |
|------|------|
| **Vue 3** (Composition API + `<script setup>`) | 组件框架 |
| **@antv/x6 v3** | 绘制线条(edge)和矩形节点(node) |
| **Arco Design Vue** | UI 组件（按钮、图标、单选框等） |

### 为什么用 X6？

X6 擅长画连线图，我们用它来：
- 画直线（主骨、大骨斜线、中骨水平线）
- 画矩形节点（加号按钮）
- 注意：**骨骼标签不用 X6 节点**，而是用 HTML overlay，这样才能支持 hover 编辑

### 为什么不直接用 SVG / Canvas？

X6 帮我们处理了坐标计算、节点点击事件等底层工作，不用自己手写 SVG 路径计算。

## 3. 数据结构

整个鱼骨图的数据存储在一个 `reactive` 对象中：

```js
const fishData = reactive({
  bigBones: [
    {
      id: 'n_1',                    // 唯一标识
      label: '大骨 1',              // 显示文本
      position: 'top',              // 'top'=主骨线上方, 'bottom'=下方
      midBones: [
        {
          id: 'n_2',
          label: '中骨 1',
          smallBones: [
            { id: 'n_3', label: '小骨 1' },
            { id: 'n_4', label: '小骨 2' },
          ]
        }
      ]
    }
  ]
})
```

**关键点**：
- 这是一棵三层树：大骨 → 中骨 → 小骨
- `position` 自动分配：偶数索引在上，奇数在下
- 每次增/删骨骼后调用 `renderGraph()` 重绘整个图

## 4. 架构概览

```
┌─────────────────────────────────────────────┐
│  fishbone-page                              │
│  ┌────────────────────────────────────────┐ │
│  │  fishbone-viewport (鼠标事件层)        │ │
│  │  ┌──────────────────────────────────┐  │ │
│  │  │  fishbone-world (transform 层)   │  │ │
│  │  │  ┌────────────────────────────┐  │  │ │
│  │  │  │  fishbone-canvas (X6 画布) │  │  │ │
│  │  │  └────────────────────────────┘  │  │ │
│  │  │  ┌─────────┐ ┌─────────┐        │  │ │
│  │  │  │ 鱼尾 SVG│ │ 鱼头 SVG│        │  │ │
│  │  │  └─────────┘ └─────────┘        │  │ │
│  │  │  ┌──────────────────────┐       │  │ │
│  │  │  │  编辑 overlay (HTML) │ × N   │  │ │
│  │  │  └──────────────────────┘       │  │ │
│  │  └──────────────────────────────────┘  │ │
│  └────────────────────────────────────────┘ │
│  ┌─────────┐  ┌─────────────────┐          │
│  │ 缩放百分比│  │ 缩放控件        │          │
│  └─────────┘  └─────────────────┘          │
│  ┌────────────────────────────────────────┐ │
│  │  底部操作栏 (编辑/详情切换 + 确定取消)  │ │
│  └────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

核心渲染流程：

```
用户操作（加骨/删骨/改标签）
  ↓
修改 fishData
  ↓
调用 renderGraph()
  ↓
① 销毁旧 X6 Graph
② 计算布局（每根骨骼的坐标）
③ 创建新 X6 Graph
④ 绘制线条和按钮节点
⑤ 生成编辑 overlay 数据（由 Vue 渲染为 HTML）
```

## 5. 布局算法详解

这是整个组件最复杂的部分。下面一步步拆解。

### 5.1 坐标系

- 原点在画布左上角
- X 轴向右为正
- Y 轴向下为正
- 主骨线在 `Y = CY`（默认 350px）处水平延伸
- 鱼头在右，鱼尾在左

### 5.2 大骨斜线长度 `calcDiag(b)`

大骨是一条 45° 的斜线。它的长度取决于有多少中骨：

```
斜线长度 = 顶端留白(headMargin) + Σ 中骨间距(midBoneSpan) + 底端留白(tailMargin)
```

因为斜线是 45°，在 X 轴和 Y 轴的投影相等：`dd = diag / √2`

### 5.3 中骨间距 `midBoneSpan(m)`

每根中骨沿斜线方向占用的空间。需要足够容纳其小骨群的垂直高度：

```
所需高度 = max(中骨自身高度 + 20, 小骨总高度 + 中骨高度)
斜线间距 = 所需高度 × √2  （因为 45° 需要补偿）
```

### 5.4 大骨分组

大骨按添加顺序每两根一组（第1根在上，第2根在下）。组从鱼头向鱼尾排列。

```
鱼尾 ←── 第3组 ── 第2组 ── 第1组 ──→ 鱼头
           ↑↓       ↑↓       ↑↓
         大骨5,6   大骨3,4   大骨1,2
```

### 5.5 鱼头固定距离

**关键设计决策**：鱼头到第一组大骨节点的距离固定为 `HEAD_TO_FIRST_BONE = 120px`。

增加中骨/小骨只会让大骨向鱼尾方向扩展，不会把鱼头推远。

### 5.6 组间距计算

每组的左延伸量 `boneLeftExtent(b)` 决定了它需要多少水平空间。相邻组之间的间距：

```
间距 = 前一组的左延伸 + GROUP_GAP(30) + 后一组的右半宽
```

## 6. 编辑交互

### 6.1 两种模式

- **编辑模式** (`mode = 'edit'`)：显示加号按钮，hover 骨骼标签变为 input
- **详情模式** (`mode = 'view'`)：只显示文本，不可交互

### 6.2 Hover 编辑原理

骨骼标签不用 X6 节点渲染，而是用 HTML `<div>` 覆盖在画布上方（editOverlays 数组）。

```
鼠标移入 → hoveringOverlayId = ov.id → v-if 切换为 <input> → 自动聚焦
鼠标移出 → hoveringOverlayId = null → v-if 切换回 <div> → 重绘画布
```

这样做的好处：
- 编辑框与文本标签完全重叠，视觉无跳动
- 背景色与骨骼颜色一致，看不出是 input

### 6.3 鱼头编辑

鱼头用同样的 hover 原理，但直接写在 template 中（不走 editOverlays），背景透明。

## 7. 画布平移与缩放

### 7.1 原理

不使用 X6 自带的平移/缩放，而是用 CSS `transform: translate(panX, panY) scale(scale)` 控制整个世界容器。

**为什么这么做？** 因为我们在 X6 画布上叠加了 HTML overlay（编辑框、鱼头、鱼尾），X6 的缩放只能缩放画布内的元素，无法同步缩放外部 HTML。用 CSS transform 可以一次性缩放所有内容。

### 7.2 拖拽平移

```
pointerdown → 记录起始位置
pointermove → panX/panY += 鼠标偏移
pointerup   → 结束拖拽
```

### 7.3 滚轮缩放

以鼠标位置为缩放中心点。数学公式：

```
newPan = mousePos - (mousePos - oldPan) × (newScale / oldScale)
```

这保证鼠标指向的画布位置在缩放前后不变。

## 8. 可调参数速查表

| 参数 | 默认值 | 位置 | 说明 |
|------|--------|------|------|
| `CY` | 350 | 全局常量 | 主骨线 Y 坐标 |
| `DIAG` | 150 | 全局常量 | 大骨斜线默认长度 |
| `MID_LEN` | 90 | 全局常量 | 中骨水平线长度 |
| `PAIR_GAP` | 60 | 全局常量 | 同组上下大骨的主骨线间距 |
| `MAX_SMALL_BONES` | 6 | 全局常量 | 每根中骨最多小骨数 |
| `GROUP_GAP` | 30 | renderGraph 内 | 相邻大骨组基础间距 |
| `HEAD_TO_FIRST_BONE` | 120 | renderGraph 内 | 鱼头到第一组的固定距离 |
| `FISH_SCALE_BASE` | 1.6 | renderGraph 内 | 鱼头鱼尾基础缩放 |
| `FISH_SCALE_MAX` | 2.5 | renderGraph 内 | 鱼头鱼尾最大缩放 |
| `SM_BOX_MIN_W` | 80 | renderGraph 内 | 小骨方框最小宽度 |
| `MID_BOX_MIN_W` | 100 | renderGraph 内 | 中骨方框最小宽度 |
| `BIG_BOX_MIN_W` | 120 | renderGraph 内 | 大骨方框最小宽度 |
| `MAX_CHARS` | 20 | 全局常量 | 标签最大字符数 |
| `LINE_CHARS` | 10 | 全局常量 | 每行最多字符数 |
| `BONE_COLORS` | 10 色数组 | 全局常量 | 大骨颜色调色板 |

## 9. 关键函数索引

### 数据操作

| 函数 | 作用 |
|------|------|
| `addBigBone()` | 新增大骨 |
| `addMidBone(bigId)` | 在指定大骨下新增中骨 |
| `addSmallBone(bigId, midId)` | 在指定中骨下新增小骨 |
| `deleteBone(delInfo)` | 删除任意骨骼 |

### 布局计算

| 函数 | 作用 |
|------|------|
| `calcDiag(b)` | 计算大骨斜线总长度 |
| `midBoneSpan(m)` | 中骨沿斜线方向的间距 |
| `boneLeftExtent(b)` | 大骨向左延伸的最大距离 |
| `totalSmallBonesH(m)` | 小骨群总高度 |
| `calcBoxW(text, minW, fs)` | 根据文本长度算方框宽度 |

### X6 绘图

| 函数 | 作用 |
|------|------|
| `addEdge(s, t, color, w)` | 画直线 |
| `addCurvedEdge(s, t, color, w)` | 画贝塞尔弧线（小骨连线） |
| `addLabelNode(...)` | 添加标签节点或编辑 overlay |
| `addBtn(...)` | 添加加号按钮 |

### 交互

| 函数 | 作用 |
|------|------|
| `onOverlayMouseEnter/Leave` | hover 切换编辑 |
| `onPointerDown/Move/Up` | 画布拖拽 |
| `onWheel` | 滚轮缩放 |
| `renderGraph()` | 核心：清除旧画布 → 计算布局 → 重新绘制 |
